{-# LANGUAGE MagicHash #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE ExistentialQuantification #-}
{-# LANGUAGE ScopedTypeVariables #-}
-- {-# LANGUAGE LambdaCase #-}
{-# LANGUAGE OverloadedStrings #-}
module DML where

import GHC.Prim(Proxy#, proxy#)
import Data.Proxy(Proxy(..))
import Data.Text.Lazy(Text)
import qualified Data.Text.Lazy as TL
import Control.Monad.IO.Class(MonadIO)
import Control.Monad.Trans.Reader(ReaderT)
import Control.Monad.Trans.RWS(RWS(..), get, tell, put, runRWS)
import Control.Monad.Catch
import GHC.TypeLits
import Data.Text.Format(format, Only(..))

import NamedRecord
import DDL

class Ins back a where
    ins :: (MonadIO m, MonadMask m)
        => [a] -> SessionMonad back m ()

-- | In many cases PK should be generated.
-- There are some possibilities:
--
-- * autogenerated PK (Sqlite, MSSQL)
-- * generated from sequence (Oracle, PostgreSQL(?)) then inserted
--
-- In all cases interface is the same.
-- If we need sequence name (Oracle) we can derive it from table name.
-- (Table name should be connected with DataRow a)
class InsAutoPK back a where
    insAuto :: (MonadIO m, MonadMask m)
            => Proxy a -> [DataRecord a] -> SessionMonad back m [PK a]

insRecCmd :: (KnownSymbol t, RowDDL back r, NamesList r, DBOption back)
    => Proxy# back -> Proxy# (t::Symbol) -> Proxy# r -> Text
insRecCmd pb pt pr
    = format "INSERT INTO {} ({}) VALUES({})"
        ( symbolVal' pt
        , TL.intercalate "," $ map TL.pack ns
        , TL.intercalate "," $ zipWith (\n -> const $ paramName pb n) [1..] ns
        )
  where
    ns = namesStrL pr

insRecCmdPars :: (KnownSymbol t, RowDDL back r, NamesList r, DBOption back)
    => Proxy# back -> Proxy# (t::Symbol) -> [r] -> (Text, [[FieldDB back]])
insRecCmdPars pb pt (rs :: [r])
    = (insRecCmd pb pt (proxy# :: Proxy# r), map (rowDb pb) rs)

class AutoGenPK back a where
    getPK :: (MonadIO m) => SessionMonad back m a

instance (AutoGenPK back a) => AutoGenPK back ((n::Symbol) :> a) where
    getPK = fmap V getPK

class Sel back a where
    sel :: (MonadIO m, MonadMask m)
        => Proxy a -> Maybe (Cond back (Record a))
                -> SessionMonad back m [Record a]

data Cond back a
    = forall b. (NamesList b, RowDDL back b, Has a b ~ True)
        => Equal b
    | forall b. (SingleField b, NamesList b, RowDDL back b, Has a b ~ True)
        => In [b]
    | forall b. (HasDef b ~ True, NamesList b, Has a b ~ True)
        => Null (Proxy b) -- | All fields in subrecord is null
    | forall b. (HasDef b ~ True, NamesList b, Has a b ~ True)
        => NotNull (Proxy b) -- | All fields in subrecord is not null
    | forall b. (NamesList b, RowDDL back b, Has a b ~ True)
        => Great b
    | forall b. (NamesList b, RowDDL back b, Has a b ~ True)
        => Least b
    | And [Cond back a]
    | Or  [Cond back a]
    | Not (Cond back a)

sqlWhere :: (DBOption back) => Cond back a -> RWS () [FieldDB back] Int Text
sqlWhere (x :: Cond back a) = case x of
    Equal b     -> rel b "="
    In (bs::[b]) ->
        fmap  ( format "{} IN ({})"
              . ((,) $ namesStr (proxy# :: Proxy# b))
              . (TL.intercalate ", ")
              )
            $ mapM (\b -> do
                    num <- get
                    tell $ rowDb (proxy# :: Proxy# back) b
                    put $ num + 1
                    return $ paramName (proxy# :: Proxy# back) num
                ) bs
    Null pb     -> isNull pb ""
    NotNull pb  -> isNull pb "NOT"
    Great b     -> rel b ">"
    Least b     -> rel b "<"
    And cs      -> ao cs " AND "
    Or cs       -> ao cs " OR "
    Not c       -> fmap (format "NOT ({})" . Only) $ sqlWhere c
  where
    rel :: (NamesList b, RowDDL back b, Has a b ~ True)
        => b -> Text -> RWS () [FieldDB back] Int Text
    rel (b :: b) op = do
        let ns = namesStrL (proxy# :: Proxy# b)
        num <- get
        tell $ rowDb (proxy# :: Proxy# back) b
        put $ num + length ns
        return
            $ TL.intercalate " AND "
            $ zipWith   (\n p ->
                    format "{} {} {}" (n,op,paramName (proxy# :: Proxy# back) p)
                ) ns [num..]
    isNull (_ :: Proxy b) (t::Text) = return
        $ TL.intercalate " AND "
        $ map (\n -> format "{} IS {} NULL" (n,t))
        $ namesStrL (proxy# :: Proxy# b)
    ao cs t = fmap (TL.intercalate t . map (format "({})" . Only)) $ mapM sqlWhere cs

-- | Convert Condition to pair: "Where-text" and "list of query-parameters".
getSqlWhere :: (DBOption back) => Cond back a -> (Text, [FieldDB back])
getSqlWhere c = let (r,_,w) = runRWS (sqlWhere c) () 1 in (r,w)

-- getSel :: (DBOption back) => Proxy a -> Cond back (Record a) -> (Text, [FieldDB back])
selRecCmdPars :: (KnownSymbol t, RowDDL back r, NamesList r, DBOption back)
    => Proxy# (t::Symbol) -> Proxy# r -> Maybe (Cond back r) -> (Text,[FieldDB back])
selRecCmdPars pt pr mc = case mc of
    Nothing ->  ( format "SELECT {} FROM {}"
                    ( TL.intercalate "," $ map TL.pack ns
                    , symbolVal' pt
                    )
                , []
                )
    Just c ->  let (w,ps) = getSqlWhere c in
                ( format "SELECT {} FROM {} WHERE {}"
                    ( TL.intercalate "," $ map TL.pack ns
                    , symbolVal' pt
                    , w
                    )
                , ps
                )
  where
    ns = namesStrL pr




