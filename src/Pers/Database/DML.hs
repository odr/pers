{-# LANGUAGE MagicHash #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE ExistentialQuantification #-}
{-# LANGUAGE ScopedTypeVariables #-}
-- {-# LANGUAGE LambdaCase #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE PolyKinds #-}
module Pers.Database.DML where

import GHC.Prim(Proxy#, proxy#)
import Data.Proxy(Proxy(..))
import Data.Text.Lazy(Text)
import qualified Data.Text.Lazy as TL
import Control.Monad.IO.Class(MonadIO)
import Control.Monad.Trans.Reader(ReaderT)
import Control.Monad.Trans.RWS(RWS(..), get, tell, put, runRWS)
import Control.Monad.Catch
import GHC.TypeLits
import Data.Type.Equality -- (type (==))
import Data.Type.Bool -- (type (||))
import Data.Text.Format(format, Only(..))
import Data.Promotion.Prelude.List
import Data.List(intercalate)

import Pers.TH
import Pers.Types
import Pers.Database.DDL

class DML (rep::Rep) back (a::k) where
    -- | Insert the list of values into database.
    -- Should create Insert-statement with parameters
    -- and execute it for all values in list
    ins :: (MonadIO m, MonadMask m) => Proxy '(rep,a) -> [VRec rep (RecordDef a)]
        -> SessionMonad back m ()
--    upd :: (MonadIO m, MonadMask m) => [a] -> SessionMonad back m ()
{-
    -- | update values with
    upd :: (MonadIO m, MonadMask m, Has a b)
        => Proxy a -> b -> Maybe (Cond back (Record a))
                -> SessionMonad back m Int
-}
    -- | Delete values by condition.
    -- Count of deleted records is returned
    del :: (MonadIO m, MonadMask m)
        => Proxy '(rep,a) -> Cond rep back (RecordDef a) -> SessionMonad back m Int
    -- | Select values by condition
    sel :: (MonadIO m, MonadMask m)
            => Proxy '(rep,a)
            -> Cond rep back (RecordDef a)
            -> SessionMonad back m [VRec rep (RecordDef a)]
    -- sel (pa :: Proxy a) c = selProj pa (Proxy :: Proxy (Record a)) c
    -- | Select part of values by condition
    selProj :: (MonadIO m, MonadMask m
            , (b :\\ NRec (RecordDef a)) ~ '[]
            , Names b
            , RowRepDDL rep back (ProjNames (RecordDef a) b)
            , Names ((NRec (RecordDef a) :\\ KeyDef a) :\\ b)
            )
        => Proxy '(rep,a,b) -> Cond rep back (RecordDef a)
        -> SessionMonad back m [VRec rep (ProjNames (RecordDef a) b)]

-- | In many cases PK should be generated.
-- There are some possibilities:
--
-- * autogenerated PK (Sqlite, MSSQL)
-- * generated from sequence (Oracle, PostgreSQL(?)) then inserted
--
-- In all cases interface is the same.
-- If we need sequence name (Oracle) we can derive it from table name.
-- (Table name should be connected with 'DataRecord a')
class InsAutoPK (rep::Rep) back (a::k) where
    insAuto :: (MonadIO m, MonadMask m)
            => Proxy '(rep,a) -> [VRec rep (DataRecordDef a)]
            -> SessionMonad back m [VRec rep (ProjNames (RecordDef a) (KeyDef a))]

insRecCmd :: (KnownSymbol t, RowRepDDL rep back r, Names (NRec r), DBOption back)
    => Proxy '(rep,back,t,r) -> Text
insRecCmd (_ :: Proxy '(rep,back,t,r))
    = format "INSERT INTO {} ({}) VALUES({})"
        ( symbolVal' (proxy# :: Proxy# t)
        , TL.intercalate "," $ map TL.pack ns
        , TL.intercalate ","
            $ zipWith (\n -> const $ paramName (proxy# :: Proxy# back) n)
                        [1..] ns
        )
  where
    ns = names (proxy# :: Proxy# (NRec r))

{-
updRecCmdPars :: (KnownSymbol t, RowDDL back r, NamesList r, DBOption back)
    => Proxy# back -> Proxy# (t::Symbol) -> Proxy# pk -> [r] -> (Text, [[FieldDB back]])
updRecCmdPars _ _ _ [] = mempty
updRecCmdPars pb pt (ppk :: Proxy# pk) ((r:rs) :: [r])
    = format "UPDATE {} SET {} WHERE {}"
        ( symbolVal' pt
        , TL.intercalate ","
            $ zipWith
                (\num name -> format "{} = {}" (TL.pack name, paramName pb num))
                [1..] ns
        , TL.intercalate "," $ zipWith (\n -> const $ paramName pb n) [1..] ns
        )
  where
    ns = namesStrL (proxy# :: Proxy# r)
    (w,ps) = getSqlWhere $ Equal $ rs ^. (recLens :: Lens' r pk)
-}
insRecCmdPars :: (KnownSymbol t, RowRepDDL rep back r, Names (NRec r), DBOption back)
    => Proxy '(rep,back,t,r) -> [VRec rep r] -> (Text, [[FieldDB back]])
insRecCmdPars (p::Proxy '(rep,back,t,r)) rs
    = (insRecCmd p, map (rowDb (proxy# :: Proxy# '(rep,back)) (Proxy::Proxy r)) rs)

class AutoGenPK back a where
    getPK :: (MonadIO m) => SessionMonad back m a

data Cond (rep::Rep) back (a :: [(Symbol,*)])
    = forall b. (Names (NRec b), RowRepDDL rep back b, (b :\\ a) ~ '[])
        => Equal (Proxy b) (VRec rep b)
    | forall s b. (KnownSymbol s, RowRepDDL rep back '[s:::b], Elem (s:::b) a ~ True)
        => In (Proxy '(rep,back,s)) [b]
    | forall b. (HasDef (VRec rep (ProjNames a b)) ~ True
                , Names b, (b :\\ NRec a) ~ '[])
        => Null (Proxy b) -- | All fields in subrecord is null
    | forall b. (HasDef (VRec rep (ProjNames a b)) ~ True
                , Names b, (b :\\ NRec a) ~ '[])
        => NotNull (Proxy b) -- | All fields in subrecord is not null
    | forall b. (Names (NRec b), RowRepDDL rep back b, (b :\\ a) ~ '[])
        => Great (Proxy b) (VRec rep b)
    | forall b. (Names (NRec b), RowRepDDL rep back b, (b :\\ a) ~ '[])
        => Least (Proxy b) (VRec rep b)
    | And [Cond rep back a]
    | Or  [Cond rep back a]
    | Not (Cond rep back a)
    | CondTrue

instance Monoid (Cond rep back a) where
    mempty = CondTrue
    c1 `mappend` c2 = And [c1,c2]
    mconcat = And

sqlWhere :: (DBOption back, Single rep)
    => Cond rep back a -> RWS () [FieldDB back] Int Text
sqlWhere (x :: Cond rep back a) = case x of
    CondTrue        -> return "1=1"
    Equal pb b      -> rel pb b "="
    In (ps :: Proxy '(rep,back,s)) (bs :: [b]) ->
        fmap  ( format "{} IN ({})"
              . ((,) $ symbolVal' (proxy# :: Proxy# s))
              . (TL.intercalate ", ")
              )
            $ mapM (\b -> do
                    num <- get
                    tell $ rowDb (proxy# :: Proxy# '(rep,back))
                                (Proxy :: Proxy '[s:::b]) (single (proxy# :: Proxy# rep) b)
                    put $ num + 1
                    return $ paramName (proxy# :: Proxy# back) num
                ) bs
    Null pb         -> isNull pb ""
    NotNull pb      -> isNull pb "NOT"
    Great pb b      -> rel pb b ">"
    Least pb b      -> rel pb b "<"
    And cs          -> ao cs " AND "
    Or cs           -> ao cs " OR "
    Not c           -> fmap (format "NOT ({})" . Only) $ sqlWhere c
  where
    rel :: (Names (NRec b), RowRepDDL rep back b)
        => Proxy b -> VRec rep b -> Text -> RWS () [FieldDB back] Int Text
    rel (pb :: Proxy b) vb op = do
        let bns = names (proxy# :: Proxy# (NRec b))
        num <- get
        tell $ rowDb (proxy# :: Proxy# '(rep,back)) pb vb
        put $ num + length bns
        return
            $ TL.intercalate " AND "
            $ zipWith   (\n p ->
                    format "{} {} {}" (n,op,paramName (proxy# :: Proxy# back) p)
                ) bns [num..]
    isNull (_ :: Proxy b) (t::Text) = return
        $ TL.intercalate " AND "
        $ map (\n -> format "{} IS {} NULL" (n,t))
        $ names (proxy# :: Proxy# b)
    ao cs t = fmap (TL.intercalate t . map (format "({})" . Only)) $ mapM sqlWhere cs

-- | Convert Condition to pair: "Where-text" and "list of query-parameters".
getSqlWhere :: (DBOption back, Single rep) => Cond rep back a -> (Text, [FieldDB back])
getSqlWhere c = let (r,_,w) = runRWS (sqlWhere c) () 1 in (r,w)

selRecCmdPars :: (KnownSymbol t, Single rep, RowRepDDL rep back r, Names a, DBOption back)
    => Proxy '(rep,t,a) -> Cond rep back (r::[(Symbol,*)])
            -> (Text,[FieldDB back])
selRecCmdPars (p::Proxy '(rep,t,a)) c =
    ( format "SELECT {} FROM {} WHERE {}"
        ( TL.intercalate "," $ map TL.pack ns
        , symbolVal' (proxy# :: Proxy# t)
        , w
        )
    , ps
    )
  where
    (w,ps) = getSqlWhere c
    ns = names (proxy# :: Proxy# a)

delRecCmdPars :: (Single rep, KnownSymbol t, DBOption back)
    => Proxy# (t::Symbol) -> Cond rep back r -> (Text,[FieldDB back])
delRecCmdPars pt c =
    ( format "DELETE FROM {} WHERE {}" ( symbolVal' pt, w )
    , ps
    )
  where
    (w,ps) = getSqlWhere c



