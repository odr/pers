{-# LANGUAGE MagicHash #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE ExistentialQuantification #-}
{-# LANGUAGE ScopedTypeVariables #-}
-- {-# LANGUAGE LambdaCase #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE PolyKinds #-}
{-# LANGUAGE FunctionalDependencies #-}
{-# LANGUAGE ConstraintKinds #-}
module Pers.Database.DML where

import GHC.Prim(Proxy#, proxy#)
import Data.Proxy(Proxy(..))
import Data.Text.Lazy(Text)
import qualified Data.Text.Lazy as TL
import Control.Monad.IO.Class(MonadIO)
import Control.Monad.Trans.Reader(ReaderT)
import Control.Monad.Trans.RWS(RWS(..), get, tell, put, runRWS)
import Control.Monad.Catch
import GHC.TypeLits
import Data.Type.Equality -- (type (==))
import Data.Type.Bool -- (type (||))
import Data.Text.Format(format, Only(..))
import Data.Promotion.Prelude.List(type (:++))
import Data.List(intercalate)
import Lens.Micro((^.))
import GHC.Exts(Constraint)

-- import Pers.TH
import Pers.Types
import Pers.Database.DDL

type family IsAutoPK  (rep::R) back kr :: Constraint
type family IsAutoPKb (rep::R) back kr :: Bool

class   ( TableLike a
        , Rep rep (RecordDef a) ar
        , Rep rep (Key a) kr
        , Rep rep (DataRecord a) dr
        )
        => DML (rep::R) back a ar kr dr
            | rep a -> ar, rep a -> kr, rep a -> dr
  where
    -- | Insert the list of values into database.
    -- Should create Insert-statement with parameters
    -- and execute it for all values in list
    ins ::  ( MonadIO m
            , MonadCatch m
            )
            => Proxy '(rep,a) -> [ar]-> SessionMonad back m ()
    -- | In many cases PK should be generated.
    -- There are some possibilities:
    --
    -- * autogenerated PK (Sqlite, MSSQL)
    -- * generated from sequence (Oracle, PostgreSQL(?)) then inserted
    --
    -- In all cases interface is the same.
    -- If we need sequence name (Oracle) we can derive it from table name.
    --
    -- If for backend and table autogeneration of id's is impossible
    -- than empty key-list is returned
    insAuto ::  ( MonadIO m
                , MonadCatch m
                , IsAutoPK rep back kr
                )
                => Proxy '(rep,a) -> [dr] -> SessionMonad back m [kr]
    -- | Simple update by pk. Return list of pk which were updated
    upd ::  ( MonadIO m
            , MonadCatch m
            )
            => Proxy '(rep,a) -> [ar] -> SessionMonad back m [kr]
    -- | Delete values by condition.
    -- Count of deleted records is returned
    del ::  ( MonadIO m
            , MonadCatch m
            )
            => Proxy '(rep,a) -> Cond rep back (RecordDef a) -> SessionMonad back m Int
    selProj ::  ( MonadIO m
                , MonadCatch m
                , ContainNames (RecordDef a) b
                , Names b
                , RowRepDDL rep back (ProjNames (RecordDef a) b) rr
            )
            => Proxy '(rep,a,b) -> Cond rep back (RecordDef a)
            -> SessionMonad back m [rr]
           -- -> SessionMonad back m [VRec rep (ProjNames (RecordDef a) b)]

-- type Proj (k::[Symbol]) a = "proj"::: ["tab":::a,"proj":::k]
-- instance

-- | Select values by condition
sel (_::Proxy '(rep, a))
    = selProj (Proxy :: Proxy '(rep,a,NRec (RecordDef a)))

upsert (p :: Proxy '(rep,a)) (xs::[ar]) = do
    res <- upd p xs
    ins p $ filter (\x -> not $ (x ^. lensPk p) `elem` res) xs

{-
-- | In many cases PK should be generated.
-- There are some possibilities:
--
-- * autogenerated PK (Sqlite, MSSQL)
-- * generated from sequence (Oracle, PostgreSQL(?)) then inserted
--
-- In all cases interface is the same.
-- If we need sequence name (Oracle) we can derive it from table name.
class   ( TableLike a
        , Rep rep (Key a) kr
        , Rep rep (DataRecord a) dr
        )
        => InsAutoPK (rep::R) back a kr dr where
    insAuto ::  ( MonadIO m
                , MonadCatch m
                )
                => Proxy '(rep,a) -> [dr] -> SessionMonad back m [kr]
-}
insRecCmd :: (KnownSymbol t, Names (NRec r), DBOption back)
    => Proxy '(rep,back,t,r) -> Text
insRecCmd (_ :: Proxy '(rep,back,t,r))
    = format "INSERT INTO {} ({}) VALUES({})"
        ( symbolVal' (proxy# :: Proxy# t)
        , TL.intercalate "," $ map TL.pack ns
        , TL.intercalate ","
            $ zipWith (\n -> const $ paramName (proxy# :: Proxy# back) n)
                        [1..] ns
        )
  where
    ns = names (proxy# :: Proxy# (NRec r))

insRecCmdPars ::    ( KnownSymbol t
                    , RowRepDDL rep back r rr
                    , Names (NRec r)
                    , DBOption back
                    )
                    => Proxy '(rep,back,t,r) -> [rr] -> (Text, [[FieldDB back]])
insRecCmdPars (p::Proxy '(rep,back,t,r)) rs
    =   ( insRecCmd p
        , map (rowDb (proxy# :: Proxy# '(rep,back)) (Proxy::Proxy r)) rs
        )
type DataKey t = DataRecord t :++ Key t
updRecCmdPars
    :: (KnownSymbol (TabName t)
        , RecLens rep (RecordDef t) (Key t) s br
        , RecLens rep (RecordDef t) (DataKey t) s ar
        , Names (KeyDef t)
        , Names (NRec (DataKey t))
        , RowRepDDL rep back (Key t) br
        , RowRepDDL rep back (DataKey t) ar
        , DBOption back
        , ContainNames (RecordDef t) (KeyDef t)
        , Single rep
        )
    => Proxy '(rep,back,t) -> [s] -> (Text, [[FieldDB back]])
updRecCmdPars (_ :: Proxy '(rep,back,t)) [] = mempty
updRecCmdPars (proxy :: Proxy '(rep,back,t)) recs@(rec:_)
    =   ( format "UPDATE {} SET {} WHERE {}"
            ( symbolVal' (proxy# :: Proxy# (TabName t))
            , TL.intercalate ","
                $ zipWith (\n s ->
                        format "{} = {}" (s, paramName (proxy# :: Proxy# back) n)
                    ) [1..] ns
            , w
            )
        , map dataKey recs
        )
  where
    ns = names (proxy# :: Proxy# (NRec (DataKey t)))
    (w,_,_) = runRWS (sqlWhere $ cond key) () (length ns + 1)
      where
        cond r = Equal (Proxy :: Proxy (KeyDef t)) r :: Cond rep back (RecordDef t)
        key = rec ^. recLens (proxy#::Proxy# '(rep,RecordDef t,Key t))
    -- (++) <$> dataDb <*> keyDb
    dataKey r
        = rowDb (proxy# :: Proxy# '(rep,back))
                (Proxy :: Proxy (DataKey t))
                (r ^. recLens (proxy#::Proxy#  '( rep, RecordDef t, DataKey t ))
                              -- (Proxy :: Proxy '(rep,t))
                )

--    keyDb   = recDbPk   proxy
--    dataDb  = recDbData proxy

-- class AutoGenPK back a where
--     getPK :: (MonadIO m) => SessionMonad back m a

data Cond (rep::R) back (a :: [(Symbol,*)])
    = forall b br.  ( Names b
                    , RowRepDDL rep back (ProjNames a b) br
                    , ContainNames a b
                    )
                    => Equal (Proxy b) br
    | forall s b br.    ( KnownSymbol s
                        , RowRepDDL rep back '[s:::b] (Singl rep b)
                        , Contains a '[s:::b]
                        )
                        => In (Proxy '(rep,back,s)) [b]
    | forall b br.  ( HasDef br ~ True
                    , Rep rep (ProjNames a b) br
                    , Names b
                    , ContainNames a b
                    )
                    => Null (Proxy b) -- | All fields in subrecord is null
    | forall b br.  ( HasDef br ~ True
                    , Rep rep (ProjNames a b) br
                    , Names b
                    , ContainNames a b
                    )
                    => NotNull (Proxy b) -- | All fields in subrecord is not null
    | forall b br.  ( Names b
                    , RowRepDDL rep back (ProjNames a b) br
                    , ContainNames a b
                    )
                    => Great (Proxy b) br
    | forall b br.  ( Names b
                    , RowRepDDL rep back (ProjNames a b) br
                    , ContainNames a b
                    )
                    => Least (Proxy b) br
    | And [Cond rep back a]
    | Or  [Cond rep back a]
    | Not (Cond rep back a)
    | CondTrue

instance Monoid (Cond rep back a) where
    mempty = CondTrue
    c1 `mappend` c2 = And [c1,c2]
    mconcat = And

sqlWhere :: (DBOption back, Single rep)
    => Cond rep back a -> RWS () [FieldDB back] Int Text
sqlWhere (x :: Cond rep back a) = case x of
    CondTrue        -> return "1=1"
    Equal pb b      -> rel pb b "="
    In (ps :: Proxy '(rep,back,s)) (bs :: [b]) ->
        fmap  ( format "{} IN ({})"
              . ((,) $ symbolVal' (proxy# :: Proxy# s))
              . (TL.intercalate ", ")
              )
            $ mapM (\b -> do
                    num <- get
                    tell $ rowDb (proxy# :: Proxy# '(rep,back))
                                (Proxy :: Proxy '[s:::b])
                                (single (proxy# :: Proxy# rep) b)
                    put $ num + 1
                    return $ paramName (proxy# :: Proxy# back) num
                ) bs
    Null pb         -> isNull pb ""
    NotNull pb      -> isNull pb "NOT"
    Great pb b      -> rel pb b ">"
    Least pb b      -> rel pb b "<"
    And cs          -> ao cs " AND "
    Or cs           -> ao cs " OR "
    Not c           -> fmap (format "NOT ({})" . Only) $ sqlWhere c
  where
    rel :: (Names b, RowRepDDL rep back (ProjNames a b) br)
         => Proxy b -> br -> Text -> RWS () [FieldDB back] Int Text
    rel (pb :: Proxy b) vb op = do
        let bns = names (proxy# :: Proxy# b)
        num <- get
        tell $ rowDb (proxy# :: Proxy# '(rep,back))
                    (Proxy :: Proxy (ProjNames a b)) vb
        put $ num + length bns
        return
            $ TL.intercalate " AND "
            $ zipWith   (\n p ->
                    format "{} {} {}"
                            (n,op,paramName (proxy# :: Proxy# back) p)
                ) bns [num..]
    isNull (_ :: Proxy b) (t::Text) = return
        $ TL.intercalate " AND "
        $ map (\n -> format "{} IS {} NULL" (n,t))
        $ names (proxy# :: Proxy# b)
    ao cs t = fmap (TL.intercalate t . map (format "({})" . Only))
            $ mapM sqlWhere cs

-- | Convert Condition to pair: "Where-text" and "list of query-parameters".
getSqlWhere ::  ( DBOption back
                , Single rep
                )
                => Cond rep back a -> (Text, [FieldDB back])
getSqlWhere c = let (r,_,w) = runRWS (sqlWhere c) () 1 in (r,w)

selRecCmdPars ::    ( KnownSymbol t
                    , Single rep
                    , Names a
                    , DBOption back
                    )
                    => Proxy '(rep,t,a)
                    -> Cond rep back r
                    -> (Text,[FieldDB back])
selRecCmdPars (p::Proxy '(rep,t,a)) c =
    ( format "SELECT {} FROM {} WHERE {}"
        ( TL.intercalate "," $ map TL.pack ns
        , symbolVal' (proxy# :: Proxy# t)
        , w
        )
    , ps
    )
  where
    (w,ps) = getSqlWhere c
    ns = names (proxy# :: Proxy# a)

delRecCmdPars :: (Single rep, KnownSymbol t, DBOption back)
    => Proxy# (t::Symbol) -> Cond rep back r -> (Text,[FieldDB back])
delRecCmdPars pt c =
    ( format "DELETE FROM {} WHERE {}" ( symbolVal' pt, w )
    , ps
    )
  where
    (w,ps) = getSqlWhere c
